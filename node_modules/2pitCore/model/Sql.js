var DB_MANAGER = process.env.DB_MANAGER;
if (!DB_MANAGER) DB_MANAGER = '2pitUtilities/Mysql';
const Database = require(DB_MANAGER);

serialize = function(node)
{
  var result = '';

  // 'property operator'
  if (['IS NULL', 'IS NOT NULL'].includes(node[0])) {
    result += node[1] + ' ' + node[0];
  }

  // 'property operator value'
  else if (['=', '!=', '<', '>', '<=', '>=', 'LIKE'].includes(node[0])) {
    result += node[1] + ' ' + node[0] + ' ' + node[2];
  }
  // 'property in (value1, value2...)'
  else if (node[0] == 'IN') {
    result += node[1] + ' IN (';
    let first = true;
    for (i = 2; i < node.length; i++) {
      if (!first) result += ', ';
      first = false;
      result += node[i];
    }
    result += ')';
  }

  // Recursive call for '(NOT expr)'
  else if (node[0] == 'NOT') {
    result += '(NOT ' + serialize(node[1]) + ')';
  }

  // Recursive call for '(expr1 AND expr2 AND...)' or '(expr1 OR expr2 OR...)'
  else {
    result += '(';
    let first = true;
    for (let i = 1; i < node.length; i++) {
      if (!first) result += ' ' + node[0] + ' ';
      first = false;
      result += serialize(node[i]);
    }
    result += ')';
  }
  return result;
}

function continuations(current) {

  return {
    current: function () { return current; },
    serialize: function ( node ) { return serialize(current); },

    // Unary operators
    isNull: function (column) { current.push(['IS NULL', column]); return this; },
    isNotNull: function (column) { current.push(['IS NOT NULL', column]); return this; },
    
    // Binary operators
    eq: function (column, value) { current.push(['=', column, '"' + value + '"']); return this; },
    ne: function (column, value) { current.push(['!=', column, '"' + value + '"']); return this; },
    lt: function (column, value) { current.push(['<', column, '"' + value + '"']); return this; },
    gt: function (column, value) { current.push(['>', column, '"' + value + '"']); return this; },
    le: function (column, value) { current.push(['<=', column, '"' + value + '"']); return this; },
    ge: function (column, value) { current.push(['>=', column, '"' + value + '"']); return this; },
    like: function (column, value) { current.push(['LIKE', column, '"' + value + '"']); return this; },

    // 'property in (value1, value2...)'
    in: function (column, values) { current.push(['IN', column, values.map( x => '"' + x + '"' )]); return this; },
  }
}

/**
 * Constructs a where structure isomorph to a parenthesized expression of the form
 *
 *   and(
 *     not().isNull('property1'),
 *     or().ge('property2', 'aa').lt('property2', -1)
 *
 * Returns: '((NOT property1 IS NULL) AND (property2 >= "aa" OR property2 < "-1"))'
 */

function and(...nodes)
{
  var node = ['AND'];
  for (i = 0; i < nodes.length; i++) node[i+1] = nodes[i].current();
  return continuations(node);
}
exports.and = and;

function or(...nodes)
{
  var node = ['OR'];
  for (i = 0; i < nodes.length; i++) node[i+1] = nodes[i].current();
  return continuations(node);
}
exports.or = or;

function not(x = null)
{
  var node = ['NOT'];
  if (x) node[1] = x.current();
  return continuations(node);
}
exports.not = not;

exports.select = function (context, connection, table, where, { columns = null, order = null, joins = null } = {}) 
{
  return new Promise ( (resolve, reject) => {
    where = and(and().eq('instance_id', context.instance.id), where);
    return Database.select(connection, table, where, { columns: columns ,Â order: order, joins: joins })
    .then( row => { resolve(row); })
    .catch( err => { reject(err); });
  });
}

