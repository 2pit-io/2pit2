Constants = require('2pitCore/model/CONSTANTS');
const Sql = require('2pitCore/model/Sql');
const or = Sql.or;
const and = Sql.and;
const not = Sql.not;
const VcardTable = require('2pitCore/Model/Vcard.js');

/**
 *
 */
exports.getConfig = function(context, type)
{
  description = context.config['core_account\/' + type];
  if (!description) description = context.config['core_account\/generic'];
  properties = { "type": type };
  Object.keys(description).forEach( propertyId => {
    property = context.config['core_account\/' + type / '\/property\/' + propertyId];
    if (!property) property = context.config['core_account\/generic\/property\/' + propertyId];
    if (property.definition != 'inline') property = context.config[property['definition']];
    if (!('private' in property)) property['private'] = false;
    if (!property['private'] || context.hasRole('dpo')) {
      if (propertyId == 'place_id') {
        property['modalities'] = [];
      }
    }
  });
}

/**
 *
 */
exports.getDescription = function(context, type)
{
  config = context.config['core_account\/' + type];
  if (!config) config = context.config['core_account\/generic'];
  
  let properties = getConfig(context, type);
  return {
    "type": type,
    "options": ('options' in config) ? config['options'] : [],
    "properties": properties,
    "search": getConfigSearch(context, type, properties),
    "list": getConfigList(context, type, properties),
    "update": getConfigUpdate(context, type, properties),
    "groupUpdate": getConfigGroupUpdate(context, type, properties),
    "export": getConfigExport(context, type, properties),
  }
}

/**
 Instanciate a new account of the given type
 */
exports.instanciate = function(context, type = null)
{
  return {
    "status": "new",
    "type": type,
    "opening_date": new Date().toISOString().substring(0, 10),
    "contact_history": [],
    "audit": [],
    "contact_1": VcardTable.instanciate(context),
    "availability_exceptions": [],
    "availability_constraints": [],
    "credits": [],
    "json_property_1": [],
    "json_property_2": [],
    "json_property_3": [],
    "json_property_4": [],
    "json_property_5": [],
    "is_notified": 1,
    "locale": context.instance.default_locale
  }
}

/**
 * Retrieve a single account based on a possibly composite key
 */
exports.get = function (context, connection, key1, column1 = 'id', key2 = null, column2 = null, key3 = null, column3 = null, key4 = null, column4 = null, key5 = null, column5 = null)
{
  return new Promise ( (resolve, reject) => {
    let where = and().eq(column1, key1);
    if (key2) where.eq(column2, key2);
    if (key3) where.eq(column3, key3);
    if (key4) where.eq(column4, key4);
    if (key5) where.eq(column5, key5);
    return Sql.select(context, connection, 'core_account', where)
    .then( row => { resolve(row[0]); })
    .catch( err => { reject(err); });
  });
}

exports.select = function (context, connection, where, { columns = null, order = null, joins = null } = {})
{
  return new Promise ( (resolve, reject) => {
    return Sql.select(context, connection, 'core_account', where, { columns: columns }, {Â order: order }, { joins: joins })
    .then( row => { resolve(row); })
    .catch( err => { reject(err); });
  });
}

