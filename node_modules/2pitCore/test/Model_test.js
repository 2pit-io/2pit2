const Config = require('2pitCore/model/Config');
const Context = require('2pitCore/model/Context');
const security = require('2pitSecurity/controller/Connection');
const Sql = require('2pitCore/model/Sql');
const or = Sql.or;
const and = Sql.and;
const not = Sql.not;
const assert = require('assert');

var config = Config.loadConfig();
var connector = security['Connection_create'];
let connection = connector();

function createContext( config, fqdn ) {
  return new Promise ( (resolve, reject) => {
    Context.create(config, connector, fqdn)
    .then( row => { resolve( row ); } )
    .catch( err => { reject( err ); } );
  });
}

/**
 * SQL, context, instance
 */ 
createContext( config, 'localhost' )
  .then( context => {

    // Check the current instance is localhost
    assert.equal(context.instance.fqdn, 'localhost');
  
    Sql.select(context, null /*connection*/, 'core_place', and().gt('core_place.id', '1'), 
    {
      columns: ['id'], 
      order: ['-core_place.id'], 
      joins: [[{ "instance": "core_instance" }, "instance.id = core_place.instance_id", [{ "instance_status": "status" }], "left"]] Â 
    })
    .then( rows => { 
     
      // Check a full sql select
      assert.equal(rows, 'SELECT core_place.id, instance.status AS instance_status FROM core_place JOIN core_instance AS instance ON instance.id = core_place.instance_id WHERE ((instance_id = "32") AND (core_place.id > "1")) ORDER BY core_place.id DESC');
      
      connection.end( err => { if (err) throw err; } );
      return rows;
    })
    .catch( err => { console.log(err) });
  })
  .catch( err => { console.log( err ) });
