const Sql = require('2pitCore/model/Sql');
const or = Sql.or;
const and = Sql.and;
const not = Sql.not;
const PlaceTable = require('2pitCore/model/Place');
const VcardTable = require('2pitCore/model/Vcard');

/**
 *
 */
exports.getConfig = function(context, connection, type)
{
  let description = context.config['core_account\/' + type];
  if (!description) description = context.config['core_account\/generic'];
  let properties = { "type": type };
  Object.keys(description).forEach( propertyId => {
    property = context.config['core_account\/' + type / '\/property\/' + propertyId];
    if (!property) property = context.config['core_account\/generic\/property\/' + propertyId];
    if (property.definition != 'inline') property = context.config[property.definition];
    if (!('private' in property)) property.private = false;
    if (!property.private || context.hasRole('dpo')) {
      if (propertyId == 'place_id') {
        property.modalities = [];
        let places = PlaceTable.select(context, connection, { order: '+caption' })
        .then( places => {
          places.forEach( place => {
            property.modalities[place.id] = place.caption;
          });
        })
        .catch( err => { throw(err); });
      }
      // Non-inline definitions on select modalities not migrated in 2pit2
      
      properties[propertyId] = property;
    }
  });
}

/**
 *
 */
exports.getConfigSearch = function(context, connection, type, configProperties)
{
  let configSearch = context.config['core_account\/search\/' + type];
  if (!configSearch) configSearch = context.config['core_account\/search\/generic'];
  let properties = [];
  Object.keys(configSearch).forEach( propertyId => {
    if (propertyId in configProperties) {
      let options = configSearch[propertyId];
      let property = configProperties[propertyId];
      properties[propertyId] = property;
      properties[propertyId].options = options;
    }
  });
  return properties;
}

/**
 *
 */
exports.getConfigList = function(context, connection, type, configProperties)
{
  let configList = context.config['core_account\/list\/' + type];
  if (!configList) configList = context.config['core_account\/list\/generic'];
  let properties = [];
  Object.keys(configList).forEach( propertyId => {
    if (propertyId in configProperties) {
      let options = configList[propertyId];
      let property = configProperties[propertyId];
      properties[propertyId] = property;
      properties[propertyId].options = options;
    }
  });
  return properties;
}

/**
 *
 */
exports.getConfigUpdate = function(context, connection, type, configProperties)
{
  let configUpdate = context.config['core_account\/update\/' + type];
  if (!configUpdate) configUpdate = context.config['core_account\/update\/generic'];
  let properties = [];
  Object.keys(configUpdate).forEach( propertyId => {
    if (propertyId in configProperties) {
      let options = configUpdate[propertyId];
      let property = configProperties[propertyId];
      properties[propertyId] = property;
      properties[propertyId].options = options;
    }
  });
  return properties;
}

/**
 *
 */
exports.getConfigGroupUpdate = function(context, connection, type, configProperties)
{
  let configUpdate = context.config['core_account\/groupUpdate\/' + type];
  if (!configUpdate) configUpdate = context.config['core_account\/groupUpdate\/generic'];
  let properties = [];
  Object.keys(configUpdate).forEach( propertyId => {
    if (propertyId in configProperties) {
      let options = configUpdate[propertyId];
      let property = configProperties[propertyId];
      properties[propertyId] = property;
      properties[propertyId].options = options;
    }
  });
  return properties;
}

/**
 *
 */
exports.getConfigExport = function(context, connection, type, configProperties)
{
  let configExport = context.config['core_account\/export\/' + type];
  if (!configExport) configExport = context.config['core_account\/groupUpdate\/generic'];
  let properties = [];
  Object.keys(configExport).forEach( propertyId => {
    if (propertyId in configProperties) {
      let options = configExport[propertyId];
      let property = configProperties[propertyId];
      properties[propertyId] = property;
      properties[propertyId].options = options;
    }
  });
  return properties;
}

/**
 *
 */
exports.getDescription = function(context, connection, type)
{
  let config = context.config['core_account\/' + type];
  if (!config) config = context.config['core_account\/generic'];
  
  let properties = getConfig(context, connection, type);
  return {
    "type": type,
    "options": ('options' in config) ? config.options : [],
    "properties": properties,
    "search": getConfigSearch(context, connection, type, properties),
    "list": getConfigList(context, connection, type, properties),
    "update": getConfigUpdate(context, connection, type, properties),
    "groupUpdate": getConfigGroupUpdate(context, connection, type, properties),
    "export": getConfigExport(context, connection, type, properties),
  }
}

/**
 Instanciate a new account of the given type
 */
exports.instanciate = function(context, type = null)
{
  return {
    "status": "new",
    "type": type,
    "opening_date": new Date().toISOString().substring(0, 10),
    "contact_history": [],
    "audit": [],
    "contact_1": VcardTable.instanciate(context),
    "availability_exceptions": [],
    "availability_constraints": [],
    "credits": [],
    "json_property_1": [],
    "json_property_2": [],
    "json_property_3": [],
    "json_property_4": [],
    "json_property_5": [],
    "is_notified": 1,
    "locale": context.instance.default_locale
  }
}

/**
 * Retrieve a single account based on a possibly composite key
 */
exports.get = function (context, connection, key1, column1 = 'id', key2 = null, column2 = null, key3 = null, column3 = null, key4 = null, column4 = null, key5 = null, column5 = null)
{
  return new Promise ( (resolve, reject) => {
    let where = and().eq(column1, key1);
    if (key2) where.eq(column2, key2);
    if (key3) where.eq(column3, key3);
    if (key4) where.eq(column4, key4);
    if (key5) where.eq(column5, key5);
    return Sql.select(context, connection, 'core_account', where)
    .then( row => { resolve(row[0]); })
    .catch( err => { reject(err); });
  });
}

exports.select = function (context, connection, where, { columns = null, order = null, joins = null } = {})
{
  return new Promise ( (resolve, reject) => {
    return Sql.select(context, connection, 'core_account', where, { columns: columns }, {Â order: order }, { joins: joins })
    .then( row => { resolve(row); })
    .catch( err => { reject(err); });
  });
}

